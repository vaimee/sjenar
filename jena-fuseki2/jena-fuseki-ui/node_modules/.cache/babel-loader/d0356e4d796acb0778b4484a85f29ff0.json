{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/progs/vaimee/sjenar/jena-fuseki2/jena-fuseki-ui/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\n\nvar _chai = require(\"chai\");\n\nvar _sinon = _interopRequireDefault(require(\"sinon\"));\n\nvar _fuseki = _interopRequireDefault(require(\"@/services/fuseki.service\"));\n\nvar _axios = _interopRequireDefault(require(\"axios\"));\n\nvar _index = require(\"@/events/index\");\n\nvar _server = _interopRequireDefault(require(\"@/model/server.status\"));\n\n/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\ndescribe('FusekiService', () => {\n  let fusekiService;\n  let clock;\n  beforeEach(async () => {\n    fusekiService = new _fuseki.default({\n      pathname: ''\n    }); // Let's freeze time! So we always get responses with `0ms` in the message.\n\n    clock = _sinon.default.useFakeTimers(new Date().getTime());\n  });\n  afterEach(() => {\n    clock.restore();\n  });\n  it('starts offline', () => {\n    (0, _chai.expect)(fusekiService.isOffline).to.equal(true);\n  });\n  it('returns server data', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'get');\n\n    stub.resolves(Promise.resolve({\n      data: 42\n    }));\n    const data = await fusekiService.getServerData();\n    (0, _chai.expect)(data).to.equal(42);\n    (0, _chai.expect)(stub.calledWith('/$/server')).to.equal(true);\n    stub.restore();\n  });\n  it('gets server status when initially offline', async () => {\n    const expected = new _server.default(true, 'Last ping returned OK in 0ms');\n\n    const stub = _sinon.default.stub(_axios.default, 'get');\n\n    const bus = _sinon.default.stub(_index.BUS, '$emit');\n\n    stub.resolves(Promise.resolve({}));\n    const serverStatus = await fusekiService.getServerStatus();\n    (0, _chai.expect)(stub.calledWith('/$/ping')).to.equal(true, 'Ping URL not called');\n    (0, _chai.expect)(bus.called).to.equal(true, 'Event BUS was not called');\n    (0, _chai.expect)(serverStatus).to.deep.equal(expected, 'Invalid server status returned');\n    (0, _chai.expect)(fusekiService.isOffline).to.equal(false, 'Wrong offline status in Fuseki Service');\n    stub.restore();\n    bus.restore();\n  });\n  it('gets server status when initially online', async () => {\n    const expected = new _server.default(true, 'Last ping returned OK in 0ms');\n\n    const stub = _sinon.default.stub(_axios.default, 'get');\n\n    const bus = _sinon.default.stub(_index.BUS, '$emit');\n\n    stub.resolves(Promise.resolve({})); // pretend it's online!\n\n    fusekiService.isOffline = false;\n    const serverStatus = await fusekiService.getServerStatus();\n    (0, _chai.expect)(stub.calledWith('/$/ping')).to.equal(true, 'Ping URL not called');\n    (0, _chai.expect)(bus.called).to.equal(false, 'Event BUS was called when it should not');\n    (0, _chai.expect)(serverStatus).to.deep.equal(expected, 'Invalid server status returned');\n    (0, _chai.expect)(fusekiService.isOffline).to.equal(false, 'Wrong offline status in Fuseki Service');\n    stub.restore();\n    bus.restore();\n  });\n  it('gets server status when initially online, but backend is offline', async () => {\n    const expected = new _server.default(false, 'Last ping returned \"Error: jena\" in 0ms');\n\n    const stub = _sinon.default.stub(_axios.default, 'get');\n\n    const bus = _sinon.default.stub(_index.BUS, '$emit');\n\n    stub.resolves(Promise.reject(new Error('jena'))); // pretend it's online!\n\n    fusekiService.isOffline = false;\n    const serverStatus = await fusekiService.getServerStatus();\n    (0, _chai.expect)(stub.calledWith('/$/ping')).to.equal(true, 'Ping URL not called');\n    (0, _chai.expect)(bus.called).to.equal(false, 'Event BUS was called when it should not');\n    (0, _chai.expect)(serverStatus).to.deep.equal(expected, 'Invalid server status returned');\n    (0, _chai.expect)(fusekiService.isOffline).to.equal(true, 'Wrong offline status in Fuseki Service');\n    stub.restore();\n    bus.restore();\n  });\n  it('gets stats for dataset', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'get');\n\n    stub.resolves(Promise.resolve({\n      data: 42\n    }));\n    const data = await fusekiService.getDatasetStats('jena');\n    (0, _chai.expect)(data).to.equal(42);\n    (0, _chai.expect)(stub.calledWith('/$/stats/jena')).to.equal(true);\n    stub.restore();\n  });\n  it('gets the dataset size', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'get');\n\n    stub.onCall(0).resolves(Promise.resolve({\n      data: {\n        results: {\n          bindings: [{\n            count: {\n              value: 42\n            }\n          }]\n        }\n      }\n    }));\n    stub.onCall(1).resolves(Promise.resolve({\n      data: {\n        results: {\n          bindings: [{\n            g: {\n              value: 'test'\n            },\n            count: {\n              value: 13\n            }\n          }]\n        }\n      }\n    }));\n    const data = await fusekiService.getDatasetSize('jena');\n    (0, _chai.expect)(data).to.deep.equal({\n      'default graph': 42,\n      test: 13\n    });\n    (0, _chai.expect)(stub.calledTwice).to.equal(true);\n    stub.restore();\n  });\n  it('calls delete endpoint', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'delete');\n\n    stub.resolves(Promise.resolve({\n      data: 42\n    }));\n    await fusekiService.deleteDataset('/jena');\n    (0, _chai.expect)(stub.calledWith('/$/datasets/jena')).to.equal(true);\n    stub.restore();\n  });\n  it('calls backup endpoint', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'post');\n\n    stub.resolves(Promise.resolve({\n      data: 42\n    }));\n    await fusekiService.backupDataset('/jena');\n    (0, _chai.expect)(stub.calledWith('/$/backup/jena')).to.equal(true);\n    stub.restore();\n  });\n  it('creates dataset', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'post');\n\n    stub.resolves(Promise.resolve({}));\n    await fusekiService.createDataset('jena', 'tbd2');\n    (0, _chai.expect)(stub.called).to.equal(true);\n    stub.restore();\n  });\n  it('creates dataset but it raises a strange error', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'post');\n\n    stub.resolves(Promise.reject(new Error('jena')));\n\n    try {\n      await fusekiService.createDataset('jena', 'tbd2');\n\n      _chai.expect.fail('Not supposed to get here');\n    } catch (error) {\n      (0, _chai.expect)(error.message).to.equal('jena');\n    }\n\n    (0, _chai.expect)(stub.called).to.equal(true);\n    stub.restore();\n  });\n  it('creates dataset but it raises a strange error with status code 200?', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'post');\n\n    const error = new Error('jena');\n    error.response = {\n      // not supposed to happen... but...\n      status: 200\n    };\n    stub.resolves(Promise.reject(error));\n\n    try {\n      await fusekiService.createDataset('jena', 'tbd2');\n\n      _chai.expect.fail('Not supposed to get here');\n    } catch (error) {\n      (0, _chai.expect)(error.message).to.equal('jena');\n    }\n\n    (0, _chai.expect)(stub.called).to.equal(true);\n    stub.restore();\n  });\n  it('creates dataset but it raises a known error with status code 409', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'post');\n\n    const error = new Error('jena');\n    error.response = {\n      status: 409\n    };\n    stub.resolves(Promise.reject(error));\n\n    try {\n      await fusekiService.createDataset('jena', 'tbd2');\n\n      _chai.expect.fail('Not supposed to get here');\n    } catch (error) {\n      (0, _chai.expect)(error.message).to.equal('failed to create dataset \"jena\", reason: there is another dataset with the same name');\n    }\n\n    (0, _chai.expect)(stub.called).to.equal(true);\n    stub.restore();\n  });\n  it('creates dataset but it raises a known error with status code different than 409', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'post');\n\n    const error = new Error('jena');\n    error.response = {\n      status: 501,\n      statusText: 'test'\n    };\n    stub.resolves(Promise.reject(error));\n\n    try {\n      await fusekiService.createDataset('jena', 'tdb2');\n\n      _chai.expect.fail('Not supposed to get here');\n    } catch (error) {\n      const expected = 'failed to create dataset \"jena\" with type tdb2, reason: HTTP status: \"501\", message: test';\n      (0, _chai.expect)(error.message).to.equal(expected);\n    }\n\n    (0, _chai.expect)(stub.called).to.equal(true);\n    stub.restore();\n  });\n  it('gets tasks for dataset', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'get');\n\n    stub.resolves(Promise.resolve({\n      id: 42\n    }));\n    const tasks = await fusekiService.getTasks();\n    (0, _chai.expect)(tasks).to.deep.equal({\n      id: 42\n    });\n    (0, _chai.expect)(stub.calledWith('/$/tasks')).to.equal(true);\n    stub.restore();\n  });\n  it('counts the graph triples', async () => {\n    // TODO: Aren't countGraphsTriples and getDatasetSize too similar? Perhaps they could be combined?\n    const stub = _sinon.default.stub(_axios.default, 'get');\n\n    stub.onCall(0).resolves(Promise.resolve({\n      data: {\n        results: {\n          bindings: [{\n            count: {\n              value: 42\n            }\n          }]\n        }\n      }\n    }));\n    stub.onCall(1).resolves(Promise.resolve({\n      data: {\n        results: {\n          bindings: [{\n            g: {\n              value: 'test'\n            },\n            count: {\n              value: 13\n            }\n          }]\n        }\n      }\n    }));\n    const data = await fusekiService.countGraphsTriples('jena');\n    (0, _chai.expect)(data).to.deep.equal({\n      default: 42,\n      test: 13\n    });\n    (0, _chai.expect)(stub.calledTwice).to.equal(true);\n    stub.restore();\n  });\n  it('fetches graphs', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'get');\n\n    stub.resolves(Promise.resolve({\n      data: 42\n    }));\n    const graph = await fusekiService.fetchGraph('jena', 'default');\n    (0, _chai.expect)(stub.called).to.equal(true);\n    (0, _chai.expect)(graph).to.deep.equal({\n      data: 42\n    });\n    stub.restore();\n  });\n  it('saves graphs', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'put');\n\n    stub.resolves(Promise.resolve({\n      data: 42\n    }));\n    const graph = await fusekiService.saveGraph('jena', 'default', 'abc');\n    (0, _chai.expect)(stub.called).to.equal(true);\n    (0, _chai.expect)(graph).to.deep.equal({\n      data: 42\n    });\n    stub.restore();\n  });\n  it('saves graphs but results in an error', async () => {\n    const stub = _sinon.default.stub(_axios.default, 'put');\n\n    const error = new Error();\n    error.response = {\n      data: '42'\n    };\n    stub.resolves(Promise.reject(error));\n\n    try {\n      await fusekiService.saveGraph('jena', 'default', 'abc');\n\n      _chai.expect.fail('Not supposed to get here');\n    } catch (error) {\n      (0, _chai.expect)(error.message).to.be.equal('42');\n    }\n\n    (0, _chai.expect)(stub.called).to.equal(true);\n    stub.restore();\n  });\n  it('creates a valid URL when using a URL graph name', () => {\n    // pathname is managed by the browser, we don't need to test if it has\n    // multiple `/`'s... in case it does, the only way to call this code\n    // is if the server accepted the URL like that, so it should be OK to\n    // keep using it as it is.\n    const tests = [{\n      pathname: '/',\n      url: '/ds/data?graph=http://example.com',\n      expected: '/ds/data?graph=http://example.com'\n    }, {\n      pathname: '/',\n      url: '//ds/data?graph=http://example.com',\n      expected: '/ds/data?graph=http://example.com'\n    }, {\n      pathname: '',\n      url: '//ds/data?graph=http://example.com',\n      expected: '/ds/data?graph=http://example.com'\n    }, {\n      pathname: '',\n      url: '',\n      expected: '/'\n    }, {\n      pathname: '/',\n      url: '/ds/data?graph=',\n      expected: '/ds/data?graph='\n    }, {\n      pathname: '/',\n      url: '/ds/data?graph=default',\n      expected: '/ds/data?graph=default'\n    }];\n    const originalPathname = fusekiService.pathname;\n\n    for (const test of tests) {\n      fusekiService.pathname = test.pathname;\n      (0, _chai.expect)(fusekiService.getFusekiUrl(test.url)).to.equal(test.expected);\n    }\n\n    fusekiService.pathname = originalPathname;\n  });\n});","map":null,"metadata":{},"sourceType":"script"}